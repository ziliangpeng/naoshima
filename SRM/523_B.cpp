#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>

#include <vector>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#include <numeric>
#include <iostream>
#include <string>
using namespace std;

#define REP(A, B) for (int A = 0; A < B; ++A)
#define FOR(A, B, C) for (int A = B; A < C; ++A)
#define SZ(A) (A.size())
#define debug(X) cout<<"  ... "#X" : "<<(X)<<"\n" 
#define PB push_back
#define ALL(X) X.begin(), X.end()
typedef long long LL;
typedef vector<int> VI;
typedef string STR;

const int MOD = 1000000007;

LL base_table[55] = {0};
LL single[55][55] = {0}; // h, w : exact
LL single_sum[55][55] = {0}; // h, w : maxi
LL group[55][55] = {0}; // h, w : maxi

void sanitize(LL& x) {
  x = ((x % MOD) + MOD) % MOD;
}

void cal_base(int k) {
  for(int w = 0; w < 53; ++w) {
    if (w == 0) base_table[w] = 1;
    else {
      for(int seg = 1; seg <= k; ++seg) {
        int pre = w - seg;
        if (pre < 0)
          break;
        else
          base_table[w] += base_table[pre];
      }
    }
    sanitize(base_table[w]);
  }
}

LL get_base(int w) {
  return base_table[w];
}

class BricksN {
public:
  int countStructures(int W, int H, int K) {
    memset(single, 0, sizeof(single));
    memset(single_sum, 0, sizeof(single_sum));
    memset(group, 0, sizeof(group));
    memset(base_table, 0, sizeof(base_table));

    // init
    for(int w = 0; w <= W; ++w) {
      group[0][w] = single[0][w] = single_sum[0][w] = 1;
    }
    for(int h = 1; h <= H; ++h) {
      group[h][0] = 1;
    }
    cal_base(K);
    
    // dp
    for (int h = 1; h <= H; ++h) {
      for(int w = 1; w <= W; ++w) {
        // cal exact
        LL base_cnt = get_base(w);

        LL up = 0;
        if (h == 1) {
          up = 1;
        } else {
          for(int sub_w = 1; sub_w <= w; ++sub_w) {
            LL sub_cnt = group[h-1][sub_w];
            sub_cnt -= group[h-2][sub_w];

            sub_cnt *= (w - sub_w + 1);
            sanitize(sub_cnt);
            up += sub_cnt;
          }
          sanitize(up);
        }

        single[h][w] = base_cnt * up;
        sanitize(single[h][w]);
        single_sum[h][w] = single_sum[h-1][w] + single[h][w];
        sanitize(single_sum[h][w]);

        // cal group
        group[h][w] = single_sum[h][w]; // this includes null combination
        for(int pre_w = 1; pre_w < w; ++pre_w) {
          for(int space = 1; space < w - pre_w; ++space) {
            int new_w = w - pre_w - space;
            LL delta = (group[h][pre_w] - 1) * (single_sum[h][new_w] - 1);
            sanitize(delta);
            group[h][w] += delta;
          }
        }
        sanitize(group[h][w]);
      }
    }

    LL ret = 1;
    for(int group_w = 1; group_w <= W; ++group_w) {
      LL smaller_group = (group[H][group_w] - 1) * (W - group_w + 1);
      sanitize(smaller_group);
      ret += smaller_group;
    }
    sanitize(ret);
    return ret;
  }
};
 
 
//// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, bool hasAnswer, int p3) {
  cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
  cout << "]" << endl;
  BricksN *obj;
  int answer;
  obj = new BricksN();
  clock_t startTime = clock();
  answer = obj->countStructures(p0, p1, p2);
  clock_t endTime = clock();
  delete obj;
  bool res;
  res = true;
  cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
  if (hasAnswer) {
    cout << "Desired answer:" << endl;
    cout << "\t" << p3 << endl;
  }
  cout << "Your answer:" << endl;
  cout << "\t" << answer << endl;
  if (hasAnswer) {
    res = answer == p3;
  }
  if (!res) {
    cout << "DOESN'T MATCH!!!!" << endl;
  } else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
    cout << "FAIL the timeout" << endl;
    res = false;
  } else if (hasAnswer) {
    cout << "Match :-)" << endl;
  } else {
    cout << "OK, but is it right?" << endl;
  }
  cout << "" << endl;
  return res;
}
int main() {
  bool all_right;
  all_right = true;
  
  int p0;
  int p1;
  int p2;
  int p3;
  
  {
  // ----- test 0 -----
  p0 = 3;
  p1 = 1;
  p2 = 3;
  p3 = 13;
  all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
  // ------------------
  }
  
  {
  // ----- test 1 -----
  p0 = 3;
  p1 = 2;
  p2 = 3;
  p3 = 83;
  all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
  // ------------------
  }
  
  {
  // ----- test 2 -----
  p0 = 1;
  p1 = 5;
  p2 = 1;
  p3 = 6;
  all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
  // ------------------
  }
  
  {
  // ----- test 3 -----
  p0 = 10;
  p1 = 10;
  p2 = 3;
  p3 = 288535435;
  all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
  // ------------------
  }
  
  if (all_right) {
    cout << "You're a stud (at least on the example cases)!" << endl;
  } else {
    cout << "Some of the test cases had errors." << endl;
  }
  return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
